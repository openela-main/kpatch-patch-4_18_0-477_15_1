From e87b1b7c69f3c746d132881a77405f55c5b2aa0c Mon Sep 17 00:00:00 2001
From: Ryan Sullivan <rysulliv@redhat.com>
Date: Tue, 25 Jul 2023 13:52:53 -0400
Subject: [KPATCH CVE-2022-42896] kpatch fixes for CVE-2022-42896
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Kernels:
4.18.0-477.10.1.el8_8
4.18.0-477.13.1.el8_8
4.18.0-477.15.1.el8_8


Kpatch-MR: https://gitlab.com/redhat/prdsc/rhel/src/kpatch/rhel-8/-/merge_requests/123
Approved-by: Yannick Cote (@ycote1)
Changes since last build:
[x86_64]:
cls_tcindex.o: changed function: tcindex_set_parms
l2cap_core.o: changed function: l2cap_recv_frame
l2cap_core.o: new function: klp_l2cap_le_sig_cmd

[ppc64le]:
cls_tcindex.o: changed function: tcindex_set_parms
l2cap_core.o: changed function: l2cap_recv_frame

---------------------------

Modifications:
Changes to the series of calling functions' names above and including the
target functions to include the prefix "klp_" to allow for a kpatch to
take place, also the affected function highest on the function tree is
optimized with '-fno-optimize-sibling-calls' here is a diagram of the new
functions and their organization:

l2cap_recv_frame
  l2cap_le_sig_channel          --> klp_l2cap_le_sig_channel
    l2cap_le_sig_cmd            --> klp_l2cap_le_sig_cmd
      l2cap_ecred_conn_req      --> klp_l2cap_ecred_conn_req
      l2cap_le_connect_req      --> klp_l2cap_le_connect_req

commit 2a15589c5bae5792168f080d6ad8eec7ddbe888e
Author: David Marlin <dmarlin@redhat.com>
Date:   Wed Mar 1 22:51:09 2023 -0600

    Bluetooth: L2CAP: Fix accepting connection request for invalid SPSM

    Bugzilla: https://bugzilla.redhat.com/2213242
    CVE: CVE-2022-42896
    Y-Commit: 05e3fd9486554fab739e789d4b05518ab532d1b3

    O-Bugzilla: https://bugzilla.redhat.com/2148404
    O-CVE: CVE-2022-42896

    commit 711f8c3fb3db61897080468586b970c87c61d9e4
    Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Date:   Mon Oct 31 16:10:32 2022 -0700

        Bluetooth: L2CAP: Fix accepting connection request for invalid SPSM

        The Bluetooth spec states that the valid range for SPSM is from
        0x0001-0x00ff so it is invalid to accept values outside of this range:

          BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A
          page 1059:
          Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges

        CVE: CVE-2022-42896
        CC: stable@vger.kernel.org
        Reported-by: Tam√°s Koczka <poprdi@google.com>
        Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
        Reviewed-by: Tedd Ho-Jeong An <tedd.an@intel.com>

    Signed-off-by: David Marlin <dmarlin@redhat.com>
    Signed-off-by: Augusto Caringi <acaringi@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

Signed-off-by: Ryan Sullivan <rysulliv@redhat.com>
---
 net/bluetooth/l2cap_core.c | 42 ++++++++++++++++++++++++++++++--------
 1 file changed, 34 insertions(+), 8 deletions(-)

diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 86ecd4ad413f..c6f1244ac177 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -5744,7 +5744,7 @@ static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
 	return err;
 }
 
-static int l2cap_le_connect_req(struct l2cap_conn *conn,
+static int klp_l2cap_le_connect_req(struct l2cap_conn *conn,
 				struct l2cap_cmd_hdr *cmd, u16 cmd_len,
 				u8 *data)
 {
@@ -5771,6 +5771,19 @@ static int l2cap_le_connect_req(struct l2cap_conn *conn,
 	BT_DBG("psm 0x%2.2x scid 0x%4.4x mtu %u mps %u", __le16_to_cpu(psm),
 	       scid, mtu, mps);
 
+	/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A
+	 * page 1059:
+	 *
+	 * Valid range: 0x0001-0x00ff
+	 *
+	 * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges
+	 */
+	if (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {
+		result = L2CAP_CR_LE_BAD_PSM;
+		chan = NULL;
+		goto response;
+	}
+
 	/* Check if we have socket listening on psm */
 	pchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,
 					 &conn->hcon->dst, LE_LINK);
@@ -5916,7 +5929,7 @@ static inline int l2cap_le_credits(struct l2cap_conn *conn,
 	return 0;
 }
 
-static inline int l2cap_ecred_conn_req(struct l2cap_conn *conn,
+static inline int klp_l2cap_ecred_conn_req(struct l2cap_conn *conn,
 				       struct l2cap_cmd_hdr *cmd, u16 cmd_len,
 				       u8 *data)
 {
@@ -5958,6 +5971,18 @@ static inline int l2cap_ecred_conn_req(struct l2cap_conn *conn,
 
 	psm  = req->psm;
 
+	/* BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A
+	 * page 1059:
+	 *
+	 * Valid range: 0x0001-0x00ff
+	 *
+	 * Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges
+	 */
+	if (!psm || __le16_to_cpu(psm) > L2CAP_PSM_LE_DYN_END) {
+		result = L2CAP_CR_LE_BAD_PSM;
+		goto response;
+	}
+
 	BT_DBG("psm 0x%2.2x mtu %u mps %u", __le16_to_cpu(psm), mtu, mps);
 
 	memset(&pdu, 0, sizeof(pdu));
@@ -6297,7 +6322,7 @@ static inline int l2cap_le_command_rej(struct l2cap_conn *conn,
 	return 0;
 }
 
-static inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,
+static inline int klp_l2cap_le_sig_cmd(struct l2cap_conn *conn,
 				   struct l2cap_cmd_hdr *cmd, u16 cmd_len,
 				   u8 *data)
 {
@@ -6320,7 +6345,7 @@ static inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,
 		break;
 
 	case L2CAP_LE_CONN_REQ:
-		err = l2cap_le_connect_req(conn, cmd, cmd_len, data);
+		err = klp_l2cap_le_connect_req(conn, cmd, cmd_len, data);
 		break;
 
 	case L2CAP_LE_CREDITS:
@@ -6328,7 +6353,7 @@ static inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,
 		break;
 
 	case L2CAP_ECRED_CONN_REQ:
-		err = l2cap_ecred_conn_req(conn, cmd, cmd_len, data);
+		err = klp_l2cap_ecred_conn_req(conn, cmd, cmd_len, data);
 		break;
 
 	case L2CAP_ECRED_CONN_RSP:
@@ -6360,7 +6385,7 @@ static inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,
 	return err;
 }
 
-static inline void l2cap_le_sig_channel(struct l2cap_conn *conn,
+static inline void klp_l2cap_le_sig_channel(struct l2cap_conn *conn,
 					struct sk_buff *skb)
 {
 	struct hci_conn *hcon = conn->hcon;
@@ -6386,7 +6411,7 @@ static inline void l2cap_le_sig_channel(struct l2cap_conn *conn,
 		goto drop;
 	}
 
-	err = l2cap_le_sig_cmd(conn, cmd, len, skb->data);
+	err = klp_l2cap_le_sig_cmd(conn, cmd, len, skb->data);
 	if (err) {
 		struct l2cap_cmd_rej_unk rej;
 
@@ -7670,6 +7695,7 @@ static void l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm,
 	kfree_skb(skb);
 }
 
+__attribute__((optimize("-fno-optimize-sibling-calls")))
 static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 {
 	struct l2cap_hdr *lh = (void *) skb->data;
@@ -7716,7 +7742,7 @@ static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 		break;
 
 	case L2CAP_CID_LE_SIGNALING:
-		l2cap_le_sig_channel(conn, skb);
+		klp_l2cap_le_sig_channel(conn, skb);
 		break;
 
 	default:
-- 
2.40.1



From 019b7722efcf64df8bc292b7d403bc4d84efc74b Mon Sep 17 00:00:00 2001
From: Ryan Sullivan <rysulliv@redhat.com>
Date: Tue, 25 Jul 2023 13:39:23 -0400
Subject: [KPATCH CVE-2023-1281] kpatch fixes for CVE-2023-1281

Kernels:
4.18.0-477.10.1.el8_8
4.18.0-477.13.1.el8_8
4.18.0-477.15.1.el8_8


Kpatch-MR: https://gitlab.com/redhat/prdsc/rhel/src/kpatch/rhel-8/-/merge_requests/125
Approved-by: Yannick Cote (@ycote1)
Changes since last build:
[x86_64]:
cls_tcindex.o: changed function: tcindex_set_parms
l2cap_core.o: changed function: l2cap_recv_frame
l2cap_core.o: new function: klp_l2cap_le_sig_cmd

[ppc64le]:
cls_tcindex.o: changed function: tcindex_set_parms
l2cap_core.o: changed function: l2cap_recv_frame

---------------------------

Modifications: none

commit dc672504161edf0f94edc1d13430882405f905ab
Author: Davide Caratti <dcaratti@redhat.com>
Date:   Wed Mar 29 10:58:33 2023 +0200

    net/sched: tcindex: update imperfect hash filters respecting rcu

    Bugzilla: https://bugzilla.redhat.com/2184146
    CVE: CVE-2023-1281
    Y-Commit: ea44299dd40cc2b846bd277b6753040b2964e621

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2181874
    O-CVE: CVE-2023-1281
    Upstream Status: net.git commit ee059170b1f7

    commit ee059170b1f7e94e55fa6cadee544e176a6e59c2
    Author: Pedro Tammela <pctammela@mojatatu.com>
    Date:   Thu Feb 9 11:37:39 2023 -0300

        net/sched: tcindex: update imperfect hash filters respecting rcu

        The imperfect hash area can be updated while packets are traversing,
        which will cause a use-after-free when 'tcf_exts_exec()' is called
        with the destroyed tcf_ext.

        CPU 0:               CPU 1:
        tcindex_set_parms    tcindex_classify
        tcindex_lookup
                             tcindex_lookup
        tcf_exts_change
                             tcf_exts_exec [UAF]

        Stop operating on the shared area directly, by using a local copy,
        and update the filter with 'rcu_replace_pointer()'. Delete the old
        filter version only after a rcu grace period elapsed.

        Fixes: 9b0d4446b569 ("net: sched: avoid atomic swap in tcf_exts_change")
        Reported-by: valis <sec@valis.email>
        Suggested-by: valis <sec@valis.email>
        Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
        Signed-off-by: Pedro Tammela <pctammela@mojatatu.com>
        Link: https://lore.kernel.org/r/20230209143739.279867-1-pctammela@mojatatu.com
        Signed-off-by: Jakub Kicinski <kuba@kernel.org>

    Signed-off-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

commit d9e202c556d466adeed44cc631b2ad4c9852890b
Author: Davide Caratti <dcaratti@redhat.com>
Date:   Wed Mar 29 10:58:33 2023 +0200

    net/sched: tcindex: search key must be 16 bits

    Bugzilla: https://bugzilla.redhat.com/2184146
    CVE: CVE-2023-1281
    Y-Commit: dfa1de4ac0853ec1dd9a4b1db8a97cdb0637ad00

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2181874
    Upstream Status: net.git commit 42018a322bd4

    commit 42018a322bd453e38b3ffee294982243e50a484f
    Author: Pedro Tammela <pctammela@mojatatu.com>
    Date:   Mon Feb 13 22:47:29 2023 -0300

        net/sched: tcindex: search key must be 16 bits

        Syzkaller found an issue where a handle greater than 16 bits would trigger
        a null-ptr-deref in the imperfect hash area update.

        general protection fault, probably for non-canonical address
        0xdffffc0000000015: 0000 [#1] PREEMPT SMP KASAN
        KASAN: null-ptr-deref in range [0x00000000000000a8-0x00000000000000af]
        CPU: 0 PID: 5070 Comm: syz-executor456 Not tainted
        6.2.0-rc7-syzkaller-00112-gc68f345b7c42 #0
        Hardware name: Google Google Compute Engine/Google Compute Engine,
        BIOS Google 01/21/2023
        RIP: 0010:tcindex_set_parms+0x1a6a/0x2990 net/sched/cls_tcindex.c:509
        Code: 01 e9 e9 fe ff ff 4c 8b bd 28 fe ff ff e8 0e 57 7d f9 48 8d bb
        a8 00 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <80> 3c
        02 00 0f 85 94 0c 00 00 48 8b 85 f8 fd ff ff 48 8b 9b a8 00
        RSP: 0018:ffffc90003d3ef88 EFLAGS: 00010202
        RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000
        RDX: 0000000000000015 RSI: ffffffff8803a102 RDI: 00000000000000a8
        RBP: ffffc90003d3f1d8 R08: 0000000000000001 R09: 0000000000000000
        R10: 0000000000000001 R11: 0000000000000000 R12: ffff88801e2b10a8
        R13: dffffc0000000000 R14: 0000000000030000 R15: ffff888017b3be00
        FS: 00005555569af300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000
        CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: 000056041c6d2000 CR3: 000000002bfca000 CR4: 00000000003506f0
        DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
        DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
        Call Trace:
        <TASK>
        tcindex_change+0x1ea/0x320 net/sched/cls_tcindex.c:572
        tc_new_tfilter+0x96e/0x2220 net/sched/cls_api.c:2155
        rtnetlink_rcv_msg+0x959/0xca0 net/core/rtnetlink.c:6132
        netlink_rcv_skb+0x165/0x440 net/netlink/af_netlink.c:2574
        netlink_unicast_kernel net/netlink/af_netlink.c:1339 [inline]
        netlink_unicast+0x547/0x7f0 net/netlink/af_netlink.c:1365
        netlink_sendmsg+0x91b/0xe10 net/netlink/af_netlink.c:1942
        sock_sendmsg_nosec net/socket.c:714 [inline]
        sock_sendmsg+0xd3/0x120 net/socket.c:734
        ____sys_sendmsg+0x334/0x8c0 net/socket.c:2476
        ___sys_sendmsg+0x110/0x1b0 net/socket.c:2530
        __sys_sendmmsg+0x18f/0x460 net/socket.c:2616
        __do_sys_sendmmsg net/socket.c:2645 [inline]
        __se_sys_sendmmsg net/socket.c:2642 [inline]
        __x64_sys_sendmmsg+0x9d/0x100 net/socket.c:2642
        do_syscall_x64 arch/x86/entry/common.c:50 [inline]
        do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80

        Fixes: ee059170b1f7 ("net/sched: tcindex: update imperfect hash filters respecting rcu")
        Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
        Signed-off-by: Pedro Tammela <pctammela@mojatatu.com>
        Reported-by: syzbot <syzkaller@googlegroups.com>
        Reviewed-by: Eric Dumazet <edumazet@google.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>

    Signed-off-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

commit 0bbc984c1bc5f991ef3217afdb41a1b18a59b9be
Author: Davide Caratti <dcaratti@redhat.com>
Date:   Thu May 4 10:51:02 2023 +0200

    net: sched: fix memory leak in tcindex_set_parms

    Bugzilla: https://bugzilla.redhat.com/2184146
    CVE: CVE-2023-1281
    Y-Commit: 3ee0788b96ec27b6ee0da2bbe164c7c0e538fcfa

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2181874
    Upstream Status: net.git commit 399ab7fe0fa0

    commit 399ab7fe0fa0d846881685fd4e57e9a8ef7559f7
    Author: Hawkins Jiawei <yin31149@gmail.com>
    Date:   Thu Dec 22 11:51:19 2022 +0800

        net: sched: fix memory leak in tcindex_set_parms

        Syzkaller reports a memory leak as follows:
        ====================================
        BUG: memory leak
        unreferenced object 0xffff88810c287f00 (size 256):
          comm "syz-executor105", pid 3600, jiffies 4294943292 (age 12.990s)
          hex dump (first 32 bytes):
            00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
            00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
          backtrace:
            [<ffffffff814cf9f0>] kmalloc_trace+0x20/0x90 mm/slab_common.c:1046
            [<ffffffff839c9e07>] kmalloc include/linux/slab.h:576 [inline]
            [<ffffffff839c9e07>] kmalloc_array include/linux/slab.h:627 [inline]
            [<ffffffff839c9e07>] kcalloc include/linux/slab.h:659 [inline]
            [<ffffffff839c9e07>] tcf_exts_init include/net/pkt_cls.h:250 [inline]
            [<ffffffff839c9e07>] tcindex_set_parms+0xa7/0xbe0 net/sched/cls_tcindex.c:342
            [<ffffffff839caa1f>] tcindex_change+0xdf/0x120 net/sched/cls_tcindex.c:553
            [<ffffffff8394db62>] tc_new_tfilter+0x4f2/0x1100 net/sched/cls_api.c:2147
            [<ffffffff8389e91c>] rtnetlink_rcv_msg+0x4dc/0x5d0 net/core/rtnetlink.c:6082
            [<ffffffff839eba67>] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2540
            [<ffffffff839eab87>] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
            [<ffffffff839eab87>] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345
            [<ffffffff839eb046>] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921
            [<ffffffff8383e796>] sock_sendmsg_nosec net/socket.c:714 [inline]
            [<ffffffff8383e796>] sock_sendmsg+0x56/0x80 net/socket.c:734
            [<ffffffff8383eb08>] ____sys_sendmsg+0x178/0x410 net/socket.c:2482
            [<ffffffff83843678>] ___sys_sendmsg+0xa8/0x110 net/socket.c:2536
            [<ffffffff838439c5>] __sys_sendmmsg+0x105/0x330 net/socket.c:2622
            [<ffffffff83843c14>] __do_sys_sendmmsg net/socket.c:2651 [inline]
            [<ffffffff83843c14>] __se_sys_sendmmsg net/socket.c:2648 [inline]
            [<ffffffff83843c14>] __x64_sys_sendmmsg+0x24/0x30 net/socket.c:2648
            [<ffffffff84605fd5>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]
            [<ffffffff84605fd5>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80
            [<ffffffff84800087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd
        ====================================

        Kernel uses tcindex_change() to change an existing
        filter properties.

        Yet the problem is that, during the process of changing,
        if `old_r` is retrieved from `p->perfect`, then
        kernel uses tcindex_alloc_perfect_hash() to newly
        allocate filter results, uses tcindex_filter_result_init()
        to clear the old filter result, without destroying
        its tcf_exts structure, which triggers the above memory leak.

        To be more specific, there are only two source for the `old_r`,
        according to the tcindex_lookup(). `old_r` is retrieved from
        `p->perfect`, or `old_r` is retrieved from `p->h`.

          * If `old_r` is retrieved from `p->perfect`, kernel uses
        tcindex_alloc_perfect_hash() to newly allocate the
        filter results. Then `r` is assigned with `cp->perfect + handle`,
        which is newly allocated. So condition `old_r && old_r != r` is
        true in this situation, and kernel uses tcindex_filter_result_init()
        to clear the old filter result, without destroying
        its tcf_exts structure

          * If `old_r` is retrieved from `p->h`, then `p->perfect` is NULL
        according to the tcindex_lookup(). Considering that `cp->h`
        is directly copied from `p->h` and `p->perfect` is NULL,
        `r` is assigned with `tcindex_lookup(cp, handle)`, whose value
        should be the same as `old_r`, so condition `old_r && old_r != r`
        is false in this situation, kernel ignores using
        tcindex_filter_result_init() to clear the old filter result.

        So only when `old_r` is retrieved from `p->perfect` does kernel use
        tcindex_filter_result_init() to clear the old filter result, which
        triggers the above memory leak.

        Considering that there already exists a tc_filter_wq workqueue
        to destroy the old tcindex_data by tcindex_partial_destroy_work()
        at the end of tcindex_set_parms(), this patch solves
        this memory leak bug by removing this old filter result
        clearing part and delegating it to the tc_filter_wq workqueue.

        Note that this patch doesn't introduce any other issues. If
        `old_r` is retrieved from `p->perfect`, this patch just
        delegates old filter result clearing part to the
        tc_filter_wq workqueue; If `old_r` is retrieved from `p->h`,
        kernel doesn't reach the old filter result clearing part, so
        removing this part has no effect.

        [Thanks to the suggestion from Jakub Kicinski, Cong Wang, Paolo Abeni
        and Dmitry Vyukov]

        Fixes: b9a24bb76bf6 ("net_sched: properly handle failure case of tcf_exts_init()")
        Link: https://lore.kernel.org/all/0000000000001de5c505ebc9ec59@google.com/
        Reported-by: syzbot+232ebdbd36706c965ebf@syzkaller.appspotmail.com
        Tested-by: syzbot+232ebdbd36706c965ebf@syzkaller.appspotmail.com
        Cc: Cong Wang <cong.wang@bytedance.com>
        Cc: Jakub Kicinski <kuba@kernel.org>
        Cc: Paolo Abeni <pabeni@redhat.com>
        Cc: Dmitry Vyukov <dvyukov@google.com>
        Acked-by: Paolo Abeni <pabeni@redhat.com>
        Signed-off-by: Hawkins Jiawei <yin31149@gmail.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>

    Signed-off-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

Signed-off-by: Ryan Sullivan <rysulliv@redhat.com>
---
 net/sched/cls_tcindex.c | 46 ++++++++++++++++++++++++++++-------------
 1 file changed, 32 insertions(+), 14 deletions(-)

diff --git a/net/sched/cls_tcindex.c b/net/sched/cls_tcindex.c
index df229a8089c9..81c36f2f684d 100644
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@ -11,6 +11,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/refcount.h>
+#include <linux/rcupdate.h>
 #include <net/act_api.h>
 #include <net/netlink.h>
 #include <net/pkt_cls.h>
@@ -331,12 +332,13 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 		  struct tcindex_filter_result *r, struct nlattr **tb,
 		  struct nlattr *est, u32 flags, struct netlink_ext_ack *extack)
 {
-	struct tcindex_filter_result new_filter_result, *old_r = r;
+	struct tcindex_filter_result new_filter_result;
 	struct tcindex_data *cp = NULL, *oldp;
 	struct tcindex_filter *f = NULL; /* make gcc behave */
 	struct tcf_result cr = {};
 	int err, balloc = 0;
 	struct tcf_exts e;
+	bool update_h = false;
 
 	err = tcf_exts_init(&e, net, TCA_TCINDEX_ACT, TCA_TCINDEX_POLICE);
 	if (err < 0)
@@ -400,7 +402,7 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 	err = tcindex_filter_result_init(&new_filter_result, cp, net);
 	if (err < 0)
 		goto errout_alloc;
-	if (old_r)
+	if (r)
 		cr = r->res;
 
 	err = -EBUSY;
@@ -454,10 +456,13 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 		}
 	}
 
-	if (cp->perfect)
+	if (cp->perfect) {
 		r = cp->perfect + handle;
-	else
-		r = tcindex_lookup(cp, handle) ? : &new_filter_result;
+	} else {
+		/* imperfect area is updated in-place using rcu */
+		update_h = !!tcindex_lookup(cp, handle);
+		r = &new_filter_result;
+	}
 
 	if (r == &new_filter_result) {
 		f = kzalloc(sizeof(*f), GFP_KERNEL);
@@ -477,21 +482,34 @@ tcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,
 		tcf_bind_filter(tp, &cr, base);
 	}
 
-	if (old_r && old_r != r) {
-		err = tcindex_filter_result_init(old_r, cp, net);
-		if (err < 0) {
-			kfree(f);
-			goto errout_alloc;
-		}
-	}
-
 	oldp = p;
 	r->res = cr;
 	tcf_exts_change(&r->exts, &e);
 
 	rcu_assign_pointer(tp->root, cp);
 
-	if (r == &new_filter_result) {
+	if (update_h) {
+		struct tcindex_filter __rcu **fp;
+		struct tcindex_filter *cf;
+
+		f->result.res = r->res;
+		tcf_exts_change(&f->result.exts, &r->exts);
+
+		/* imperfect area bucket */
+		fp = cp->h + (handle % cp->hash);
+
+		/* lookup the filter, guaranteed to exist */
+		for (cf = rcu_dereference_bh_rtnl(*fp); cf;
+		     fp = &cf->next, cf = rcu_dereference_bh_rtnl(*fp))
+			if (cf->key == (u16)handle)
+				break;
+
+		f->next = cf->next;
+
+		cf = rcu_replace_pointer(*fp, f, 1);
+		tcf_exts_get_net(&cf->result.exts);
+		tcf_queue_work(&cf->rwork, tcindex_destroy_fexts_work);
+	} else if (r == &new_filter_result) {
 		struct tcindex_filter *nfp;
 		struct tcindex_filter __rcu **fp;
 
-- 
2.40.1


